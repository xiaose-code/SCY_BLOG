---
title: 网络核心知识总结
date: 2023-06-09 10:07:45
permalink: /pages/7b1cb2/
---
# 计算机网络总结

## 基础

### 网络分层模型

#### OSI 七层模型是什么？每一层的作用是什么？

OSI 体系结构是**法律**上的国家标准，从上往下讲分别是：

1. 应用层 -- 作用是 -- 为计算机用户提供服务
2. 表示层 -- 作用是 -- 数据处理(编解码、加密解密、压缩解压缩)
3. 会话层 -- 作用是 -- 管理 (建立、维护、重连) 应用程序之间的会话
4. 传输层 -- 作用是 -- 为两台主机进程之间的通信提供通用的数据传输服务
5. 网络层 -- 作用是 -- 路由和寻址(决定数据在网络的游走路径)
6. 数据链路层 -- 作用是 -- 帧编码和误差纠正控制
7. 物理层 -- 作用是 -- 透明地传送比特流传输

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.8mdi6rjma8k.webp)

>**OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。**

#### TCP/IP 四层模型是什么？每一层的作用是什么？

**TCP/IP 四层模型** 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，是**事实**上的国家标准。

它们分别是：

1. 应用层 -- 整合了 [应用层、表示层、会话层]
2. 传输层
3. 网络层
4. 网络接口层 -- 整合了 [数据链路层、物理层]

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.6er4ni3w9h40.webp)

***作用***

应用层 -- 主要作用是 -- 解决通过应用进程的交互来实现特定网络应用的问题

传输层 -- 主要作用是 -- 解决进程之间基于网络的通信问题

网络层 -- 主要作用是 -- 解决分组在多个网络上传输 (路由) 的问题

网络接口层 -- 主要作用是 -- 解决分组在一个网络 (或一段链路) 上传输以及使用何种信号来传输比特的问题

#### 为什么网络要分层？

计算机网络体系结构之所以要分层，主要是为了**实现模块化**和**分工合作**的设计思想，将整个网络系统分解为若干个相对独立的层次，每层都有自己的功能和责任，**便于设计、实现和维护网络系统**。同时，分层还可以**提高网络的灵活性和可扩展性**，使得网络系统更易于适应不同的应用需求和技术变革。

#### 各层的封装格式是怎么样的？

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.4cfkenf7dz20.webp)

1. **网络接口层**的传输单位是帧（frame），更底下的是 比特流
2. IP **网络层**的传输单位是包（packet）
3. TCP **传输层**的传输单位是段（segment）
4. HTTP **应用层**的传输单位则是消息或报文（message）。

但这些名词并没有什么本质的区分，可以统称为数据包。

#### 常见网络协议

##### 应用层有哪些常见的协议？

9 个：HTTP、SMTP、POP3、IMAP、FTP、Telnet、SSH、RTP、DNS

概览如下图：

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.4n590h0736w0.webp)

- **HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
- **SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）**：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。
- **POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。
- **FTP（File Transfer Protocol，文件传输协议）** : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。
- **Telnet（远程登陆协议）**：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。
- **SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务
- **RTP（Real-time Transport Protocol，实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。
- **DNS（Domain Name System，域名管理系统）**: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

##### 传输层有哪些常见的协议？

传输控制协议 TCP 和 用户数据协议 UDP

- **TCP（Transmission Control Protocol，传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。
- **UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。

##### 网络层有哪些常见的协议？

7 个：IP、ARP、ICMP、NAT、OSPF、RIP、BGP

- **IP（Internet Protocol，网际协议）**：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。
- **ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。
- **ICMP（Internet Control Message Protocol，互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。
- **NAT（Network Address Translation，网络地址转换协议）**：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。
- **OSPF（Open Shortest Path First，开放式最短路径优先）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。
- **RIP(Routing Information Protocol，路由信息协议）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
- **BGP（Border Gateway Protocol，边界网关协议）**：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。

## HTTP（应用层）

### 从输入 URL 到页面展示到底发生了什么？（重要）

总体来说分为以下几个过程:

1. DNS 解析 -- 浏览器查找域名的 IP 地址(DNS查找过程: 浏览器缓存、路由器缓存、DNS 缓存)
2. 与服务器建立 TCP 连接
3. 浏览器向 web 服务器发送一个 HTTP 请求(cookies会随着请求发送给服务器)
4. 服务器处理请求并返回 HTTP 报文(请求 处理请求 & 它的参数、cookies、生成一个 HTML 响应)
5. 浏览器解析渲染页面 -- 也就是浏览器开始显示 HTML
6. 连接结束

期间使用到的**协议**：

1. DNS: 获取域名对应 IP
2. TCP: 与服务器建立 TCP 连接
3. IP: 建立 TCP 协议时，需要发送数据，发送数据在网络层使用 IP 协议
4. OSPF: IP 数据包在路由器之间，路由选择使用 OPSF 协议
5. ARP: 路由器在与服务器通信时，需要将 ip 地址转换为 MAC 地址，需要使用 ARP 协议
6. HTTP: 在 TCP 建立完成后，使用 HTTP 协议访问网页

> 思考：ip 地址与 MAC 地址的区别？

### HTTP 状态码有哪些？

HTTP 状态码主要有五大类，用于描述 HTTP 请求的结果。

比如：

|      | 类别                            | 具体含义                                                     | 常见状态码         |
| ---- | ------------------------------- | ------------------------------------------------------------ | ------------------ |
| 1xx  | Informational(信息性状态码)     | 提示信息，接收的请求正在处理，表示目前是协议处理的中间状态，还需要后续的操作 |                    |
| 2xx  | Success (成功状态码)            | 成功，请求正常处理完毕                                       | 200、204、206      |
| 3xx  | Redirection (重定向状态码)      | 重定向，资源位置发生变动，需要客户端重新发送请求             | 301、302、304      |
| 4xx  | Client Error (客户端错误状态码) | 客户端错误，请求报文有误，服务器无法处理请求                 | 400、403、404      |
| 5xx  | Server Error (服务器错误状态码) | 服务器错误，服务器在处理请求时内部发生了错误                 | 500、501、502、503 |

>思考：每个常见状态码的含义？

### HTTP Header 中常见的字段有哪些？

#### *1、Host 字段*

客户端发送请求时，用来指定**服务器的域名**。

有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

示例

```text
Host: www.A.com

Host: en.wikipedia.org:80
```

#### *2、Content-Length 字段*

服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的**数据长度**。

比如：

```text
Content-Length: 1000
```

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.7hv9gt57flg0.webp)

如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的**字节就属于下一个回应了**。

>PS：大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**。
>
>
>
>***什么是 TCP 粘包问题？***

#### *3、Connection 字段*

`Connection` 字段最常用于客户端**要求**服务器使用「HTTP 长连接」机制，以便其他请求复用。

HTTP 长连接的**特点**是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```text
Connection: Keep-Alive
```

开启了 HTTP Keep-Alive 机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。

>PS：HTTP Keep-Alive 和 TCP Keepalive 是不一样的，具体可以看这篇文章：[TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？](https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html)

#### *4、Content-Type 字段*

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。（即代表**数据格式**）

比如：

```text
// 下面类型表明，发送的是网页，而且编码是 UTF-8。

Content-Type: text/html; Charset=utf-8
```

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```text
// 客户端声明自己可以接受任何格式的数据。

Accept: */*
```

具体如图所示：

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.228bv9gps7mo.webp)

#### *5、Content-Encoding 字段*

`Content-Encoding` 字段指的是**数据的压缩方法**。表示服务器返回的数据使用了什么压缩格式

```text
// 服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压

Content-Encoding: gzip
```

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```text
// 客户端能接受 gzip 和 deflate 的压缩数据

Accept-Encoding: gzip, deflate
```

具体如图所示：

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.3f6u2m8uwj60.webp)

#### 其他字段

![1686320824926](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/1686320824926.4z12r3gpjnw0.webp)

### HTTP 和 HTTPS 有什么区别？（重要）4

主要有四个区别：

1. **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
2. **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
3. **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，**HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。**
4. **SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。**使用 HTTPS 协议的网站在搜索结果中可能会被优先显示**，从而对 SEO 产生影响。

### HTTP/1.0 和 HTTP/1.1 有什么区别？5

主要有五类区别：

1. **连接方式**: 

   - HTTP/1.0 为短连接；
   - HTTP/1.1 支持长连接。

2. **状态响应码**: HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。

   > 比如说：
   >
   > - `100 (Continue)`——在请求大资源前的预热请求；
   > - `206 (Partial Content)`——范围请求的标识码；
   > - `409 (Conflict)`——请求与当前资源的规定冲突；
   > - `410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。

3. **缓存机制**: 

   - 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准；

   - HTTP/1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

4. **带宽**：

   - HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
   - HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 `206（Partial Content）`，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

5. **Host 头（Host Header）处理**: 

   - HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能；
   - 而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

### HTTP/1.1 和 HTTP/2.0 有什么区别？4

主要有四个区别：

1. **IO 多路复用（Multiplexing）**：

   - HTTP/1.1 使用串行方式，每个请求和响应都需要独立的连接。
   - 而 HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。

2. **二进制帧（Binary Frames）**：

   - HTTP/1.1 则使用文本格式的报文。
   - 而 HTTP/2.0 使用二进制帧进行数据传输。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。

3. **头部压缩（Header Compression）**：

   - HTTP/1.1 支持 `Body` 压缩，不支持 `Header` 压缩。

   - HTTP/2.0 支持对 `Header` 压缩，减少了网络开销。

4. **服务器推送（Server Push）**：

   - HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。
   - 而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

### HTTP/2.0 和 HTTP/3.0 有什么区别？5

1. **传输协议**：

   - HTTP/2.0 是**基于 TCP 协议实现**的。

   - HTTP/3.0 **新增了 QUIC**（Quick UDP Internet Connections）协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。

     > 你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。

2. **连接建立**：

   - HTTP/2.0 **需要经过经典的 TCP 三次握手过程**（一般是 3 个 RTT）。
   - 而 HTTP/3.0 由于 QUIC 协议的特性，**可以避免 TCP 三次握手的延迟**，允许在第一次连接时发送数据（0 个 RTT，零往返时间）。

3. **队头阻塞**：

   - HTTP/2.0 多请求复用一个 TCP 连接，**一旦发生丢包，就会阻塞住所有的 HTTP 请求**。
   - 而 HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，**某个数据流发生丢包了，其数据流不受影响**（本质上是多路复用+轮询）。

4. **错误恢复**：

   - HTTP/2.0 **需要依赖于 TCP 的错误恢复机制**。

   - 而 HTTP/3.0 **具有更好的错误恢复机制**，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。

5. **安全性**：

   HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。

   - HTTP/2.0 使用 TLS 协议进行加密。
   - 而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。

### 总结

![http-协议](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/http-协议.fx2rzvhgmk0.webp)

### HTTP 是不保存状态的协议, 如何保存用户状态？

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 **HTTP 协议自身不对请求和响应之间的通信状态进行保存**。那么我们保存用户状态呢？

**使用 Session 机制。**

Session 机制的存在就是为了解决这个问题，Session 的主要作用就是：通过服务端记录用户的状态。

- **典型的场景**是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

- 在服务端**保存 Session 的方法**很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。

***1、既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？***

大部分情况下，都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

***2、Cookie 被禁用怎么办?***

最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。

### URI 和 URL 的区别是什么?

- URI(Uniform Resource Identifier)：是统一资源**标志符**，可以**唯一标识一个资源**。

  URI 示例，**比如一个电子邮件地址**： 

  ```URI
  mailto:example@example.com
  
  // mailto: 是 URI 方案，后跟实际的电子邮件地址。
  ```

- URL(Uniform Resource Locator)：是统一资源**定位符**，可以**提供该资源的路径**（用于标识资源的地址）。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

  URL 示例，**比如网页的地址**：

  ```URL
  https://www.example.com/index.html
  
  https:// 是 URL 的协议部分
  www.example.com 是主机名
  index.html 是在服务器上的文件路径
  ```

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅可以唯一标识资源，而且还提供了定位该资源的信息。

### Cookie 和 Session 有什么区别？

Cookie 和 Session 都是在 Web 开发中**用于管理用户状态的技术**，它们的主要区别有 5 个：

1. **存储位置：**

   Cookie 保存在**客户端**，而 Session 保存在**服务器端**。

2. **安全性：**

   由于 Cookie 保存在客户端，所以 **Cookie 存在被恶意篡改的风险**；而 Session 保存在服务器端，**相对来说更加安全**。

3. **存储内容：**

   Cookie 保存的信息是**明文**的，而 Session 保存的信息是**加密**的。

4. **生命周期：**

   Cookie **可以设置过期时间**，而 Session **默认情况下在用户关闭浏览器后就会过期**。

5. **存储容量**：

   Cookie 存储的数据量**有限制**，一般为 4KB 左右；而 Session 存储的数据量**没有限制**，但是过多的 Session 会占用服务器的内存。

### GET 与 POST

#### GET 和 POST 有什么区别？

**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。（用 URL 传输数据）

GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的**长度有限制**。（用 body 传输数据）

> HTTP协议本身对 URL 长度并没有做任何规定。

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。

POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

#### GET 和 POST 方法都是安全和幂等的吗？

> 安全和幂等的概念：
>
> - 在 HTTP 协议里，所谓的「安全」是指**请求方法不会「破坏」服务器上的资源。**
> - 所谓的「幂等」，意思是**多次执行相同的操作，结果都是「相同」的。**

*1、从 RFC 规范定义的语义来看：*

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

简单总结一下：

- GET 的语义是请求获取指定的资源。GET 方法是**安全、幂等、可被缓存**的。
- POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST **不安全，不幂等，（大部分实现）不可缓存**。

*2、从实际过程来看*

在实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

#### GET 一定比 POST 安全吗？

如果单从**信息是否会被泄漏**来判定安全性的话，并不能说 GET 不如 POST 安全。

> 虽然 POST 用 body 传输数据，
>
> 而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到

因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是**只要抓个包就都能看到了**。

> 所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。

#### GET 请求可以带 body 吗？

可以带。

- RFC 规范并没有规定 GET 请求不能带 body。
- 理论上，任何请求都是可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个**语义不需要用到 body**。

> 另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

POST 请求中的参数通常包含在请求的消息体中，而不是像 GET 请求一样包含在 URL 中。以下是一个登录功能的例子：

```text
POST /api/login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
username=johndoe&password=secret
```

在这个例子中，我们向 `example.com` 发送了一个 POST 请求，请求的路径为 `/api/login`，请求头中包含了 `Content-Type` 字段，表示请求消息体的格式为 `application/x-www-form-urlencoded`，请求消息体中包含了两个参数 `username` 和 `password`。

在实际开发中，我们可以通过发送 POST 请求并在请求消息体中包含参数，来向服务器提交数据。

#### 什么是 RFC 协议？

RFC（Request for Comments）**是一系列文件的集合**，这些文件包含了关于互联网技术、协议、体系结构和操作的**信息和思想**。

RFC 文件由互联网工程任务组（IETF）进行维护和发布。IETF 是一个开放的、国际性的组织，旨在推动互联网的技术和标准的发展。 

RFC 文件通常描述了互联网标准、协议、流程、算法、编码规范和其他相关主题。RFC 文件的**主要目的是促进开放、自由和协作式的标准制定过程，以便所有人都可以参与互联网标准的制定和实施**。

RFC 文件不仅仅是一堆文本文件，它们还**会被设计成软件规范和协议**，以便开发人员可以根据这些规范开发互联网应用程序。 RFC 文件是互联网技术发展史上非常重要的一部分，每个 RFC 文件都有一个唯一的编号和标题，例如 RFC 2616，也称为 HTTP/1.1。这个 RFC 文件定义了 HTTP 协议的版本 1.1，包括 HTTP 请求和响应的格式、语法和语义。其他一些著名的 RFC 文件包括 RFC 793（TCP 协议）、RFC 821（SMTP 协议）和RFC 2822（电子邮件格式）。

## TCP 与 UDP（传输层）

### TCP 与 UDP 的区别（重要）

总结来说：

UDP 在传送数据之前不需要先建立连接，是无状态的，传输不可靠但效率较高，支持一对多通信；

TCP 在传送数据之前必须先建立连接，是有状态的，提供可靠传输服务，只支持点对点通信。



1. **是否面向连接**：

   - TCP 在传送数据之前必须先建立连接。
   - 而 UDP 在传送数据之前不需要先建立连接。

2. **是否是可靠传输**：

   - TCP 在传递数据之前，会有三次握手来建立连接，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
   - 而远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。

3. **是否有状态**：

   - TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。
   - 而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。

4. **传输效率**：

   由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 **TCP 的传输效率要比 UDP 低很多**。

5. **传输形式**：

   - TCP 是面向字节流的，
   - UDP 是面向报文的。

6. **首部开销**：

   TCP 首部开销比 UDP 首部开销要大。

7. **是否提供广播或多播服务**：

   - TCP 只支持点对点通信，
   - 而 UDP 支持一对一、一对多、多对一、多对多。

### 什么时候选择 TCP，什么时候选 UDP?

- **UDP 一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你**看视频**即使少个一两帧，实际给人的感觉区别也不大。
- **TCP 用于对传输准确性要求特别高的场景**，比如**文件传输**、发送和接收邮件、远程登录等等。

### HTTP 基于 TCP 还是 UDP？

- HTTP/3.0 之前是基于 TCP 协议的，
- 而 HTTP/3.0 改用 **基于 UDP 的 QUIC 协议** 。

### 使用 TCP 的协议有哪些?

常见的有：

1. HTTP（HyperText Transfer Protocol，**超文本传输协议**）
2. FTP（File Transfer Protocol，**文件传输协议**）
3. SMTP（Simple Mail Transfer Protocol，**简单邮件传输协议**）
4. Telnet（**远程登录协议**）
5. SSH（Secure Shell，**安全外壳协议**）

### 使用 UDP 的协议有哪些?

常见的有

1. **DNS**（Domain Name System，域名系统）
2. DHCP（Dynamic Host Configuration Protocol，**动态主机配置协议**）
3. TFTP（Trivial File Transfer Protocol，**简单文件传输协议**）
4. SNMP（Simple Network Management Protocol，**简单网络管理协议**）

## IP（网络层）

### IP 协议的作⽤是什么？

**IP（Internet Protocol，网际协议）** 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议。

主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

### 什么是 IP 地址？

IP 地址是 Internet Protocol Address（网际协议地址）的缩写，**是互联网中用于识别设备的数字标识**。



在 TCP/IP 协议中，IP 地址用于标识网络中的主机或设备。它是一个 32 位二进制数，通常用“点分十进制”表示法表示，即四个用点分隔的十进制数，每个数的取值范围为 0-255。

IP 地址分为公网 IP 地址和私有 IP 地址两种类型。

- 公网 IP 地址是唯一的，由 ISP（Internet Service Provider，互联网服务提供商）分配，用于在 Internet 上识别设备；
- 私有 IP 地址不唯一，用于在局域网内标识设备。常见的私有 IP 地址有 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 等。

### IP 寻址如何⼯作？

IP 寻址是指：确定数据包在网络中的传输路径，使其能够正确地到达目标设备。

IP 寻址的过程主要分为四个步骤：

1. **分配 IP 地址**：每个设备在接入网络时，需要被分配一个唯一的IP 地址。
   - 公网 IP 地址由 ISP（Internet Service Provider，互联网服务提供商）分配，
   - 而私有 IP 地址通常由网络管理员进行分配。
2. **确定子网掩码**：子网掩码用于将一个 IP 地址分成网络部分和主机部分。**在同一网络中的设备必须使用相同的子网掩码**。
3. **确定默认网关**：默认网关（也称为默认路由）是一个设备的出口地址，**用于将数据包发送到其他网络**。默认网关通常是网络中的路由器。
4. **确定 DNS 服务器**：DNS 服务器用于将域名解析为 IP 地址。当设备需要访问 Internet 上的其他设备时，需要**向 DNS 服务器查询目标设备的 IP 地址**。
5. **进行 IP 寻址**：当设备需要向其他设备发送数据包时，它首先需要确定目标设备的 IP 地址。设备会比较自己的 IP 地址和目标设备的 IP 地址，**确定它们是否在同一网段中**。
   - 如果目标设备与自己在同一网段中，则设备会直接发送数据包到目标设备；
   - 如果目标设备与自己不在同一网段中，则设备会将数据包发送到默认网关，由默认网关将数据包转发到目标设备所在的网络中。

### IPv4 和 IPv6 有什么区别？

IPv4 和 IPv6 之间的主要区别在于**地址空间大小**和**地址表示方式**。

1. 地址空间大小：
   - IPv4 使用 **32 位地址**，可以表示约 42 亿（2^32）个可用 IP 地址。随着互联网的快速发展，IPv4 地址已经不足以满足需求。
   - IPv6 使用 **128 位地址**，可以表示约 340 万亿亿亿亿（2^128）个地址，将满足未来的地址需求。

2. 地址表示方式：
   - IPv4 地址使用**点分十进制表示法**，例如 192.168.1.1；
   - IPv6 地址使用**冒号分组表示法**，例如 2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了缩短 IPv6 地址的长度，IPv6 地址中连续的 0 可以省略，例如 2001:0db8:85a3**::**8a2e:0370:7334。

除了地址空间大小和地址表示方式之外，IPv6还具有一些其他的优势，例如**更好的安全性、更高的性能和更智能的路由选择**。

## PING

### ping 命令的作用是什么？

ping 命令是一种常用的**网络诊断工具**，经常**用来测试网络中主机之间的连通性和网络延迟**。

- 如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。
- 如果往返时间（RTT）过高，则表明网络延迟过高。

### PING 命令的工作原理是什么？

ping 是基于 `ICMP` 协议工作的，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。

具体来说：

- 首先 PING 命令会向目标主机发送一个 ICMP Echo Request（请求报文）。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply（响应报文），PING 命令会接收并分析该数据包，并计算出往返时间（RTT）和丢包率等信息。

> PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型。、
>
> - 8 - 代表回送请求
> - 0 - 代表回送应答
>
> 
>
> PING 命令利用 ICMP 协议的 ECHO REQUEST 和 ECHO REPLY 消息来测试**目标主机的可达性**和**网络质量**。

### 什么是 ICMP 协议？

ICMP 全称是 **Internet Control Message Protocol**，也就是**互联网控制报文协议**。

ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。

ICMP 包头的**类型**字段，大致可以分为两大类：

- 一类是用于诊断的查询消息，也就是「**查询报文类型**」
- 另一类是通知出错原因的错误消息，也就是「**差错报文类型**」

![image](https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/network/image.supojqic5f4.webp)

### ping 命令的输出结果什么样子的？

PING 命令的输出结果通常包括以下几部分信息：

1. **ICMP Echo Request（请求报文）信息**：序列号、TTL（Time to Live）值。
2. **目标主机的域名或 IP 地址**：输出结果的第一行。
3. **往返时间（RTT，Round-Trip Time）**：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。
4. **统计结果（Statistics）**：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。

下面是一个 ping 百度的例子：

```sh
# 发送4个PING请求数据包到 www.baidu.com
❯ ping -c 4 www.baidu.com

PING www.a.shifen.com (14.119.104.189): 56 data bytes
64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms
64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms
64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms
64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms

# 输出的结果
--- www.a.shifen.com ping statistics ---
4 packets transmitted, 4 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms
```

## DNS

### 什么是 DNS？

DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个**重要协议**。

DNS 要解决的是**域名和 IP 地址的映射问题**。

> 目前 DNS 的设计采用的是分布式、层次数据库结构，**DNS 是应用层协议，基于 UDP 协议之上，端口为 53** 

### DNS 的作用是什么？

DNS（Domain Name System）的作用是：**将域名转换为 IP 地址，使得用户可以通过更易于记忆的域名来访问网站和其他网络服务**。

在互联网上，每个设备都需要一个唯一的 IP 地址来进行通信，而使用域名可以避免用户需要记住许多复杂的 IP 地址。DNS 将域名映射到对应的 IP 地址，使得用户在输入域名时可以自动向正确的 IP 地址发送请求，从而访问相应的网站或服务。

### DNS 服务器有哪些？

DNS 服务器**自底向上**可以依次分为以下 4 个层级：

根 -> 顶级 -> 权威 -> 本地

所有 DNS 服务器都属于这四个类别之一。

>1. **根域名服务器**。它是互联网上**最高级别**的 DNS 服务器，管理顶级域名服务器的地址，并提供 DNS 递归解析服务。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。
>2. **顶级域名服务器（TLD 服务器）**。顶级域是指域名的后缀，如 `com`、`org`、`net` 和 `edu` 等。国家也有自己的顶级域，如 `uk`、`fr` 和 `ca`。TLD 服务器提供了权威 DNS 服务器的 IP 地址。
>3. **权威域名服务器**。它是管理特定域名下所有主机的 DNS 服务器，例如某个网站的域名服务器。权威域名服务器存储着该域名下所有主机的 IP 地址信息，它们只回答自己管理的域名和主机的 DNS 查询请求。
>4. **本地域名服务器**。它是用户计算机或局域网中的 DNS 服务器，**用于缓存 DNS 查询结果，并提供 DNS 递归解析服务**。
>
>  - 当用户计算机发起 DNS 查询请求时，本地域名服务器会优先检查自己的缓存中是否有该域名对应的 IP 地址信息。
>  - 如果没有，则向根域名服务器发起 DNS 查询请求，按照自底向上的顺序逐级向下查询，直到找到权威域名服务器并获得 IP 地址信息，最后将结果返回给用户计算机。

### DNS 解析的过程是什么样的？

DNS 解析过程大致可以分为以下几步：

1. 浏览器发起 URL 请求，时
2. 操作系统向本地 DNS 服务器查询，
3. 本地 DNS 服务器向根域名服务器、顶级域名服务器和权威域名服务器查询，
4. 最终返回 IP 地址。

## ARP

### 什么是 Mac 地址？

简单来说：

Mac 地址常被称为物理地址，是用于识别网络设备的唯一标识符且固定不变。

> MAC 地址，全称 Media Access Control Address，即媒体访问控制地址，也称为物理地址或硬件地址，是用于识别网络设备的唯一标识符。MAC 地址通常由 48 位二进制数组成，其中前 24 位表示厂商代码，后 24 位为该厂商设备的序列号。
>
> **MAC 地址是数据链路层（OSI模型第二层）的概念**，用于在同一局域网内识别和寻址网络设备。
>
> **在局域网中，每个网络设备都有一个唯一的 MAC 地址**。当一个网络设备需要发送数据时，它首先会在目标设备的 ARP 缓存中查找目标设备的 MAC 地址，如果没有找到，则向局域网广播 ARP 请求，请求目标设备的 MAC 地址。当目标设备收到 ARP 请求后，它会向发送设备回复一个 ARP 响应，包含自己的 MAC 地址。发送设备在收到 ARP 响应后，就可以使用目标设备的 MAC 地址来发送数据了。
>
> **MAC 地址是固定不变的**，一般情况下不会被修改。在实际应用中，MAC 地址被广泛应用于网络设备的管理和安全控制，如网络设备的远程管理、访问控制列表等。

### ARP 协议解决了什么问题？

ARP 协议，全称 **地址解析协议（Address Resolution Protocol）**，解决了 IP 地址转 MAC 地址的一些问题。

因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处

> - IP 地址属于逻辑地址，
>
> - 而 MAC 地址才是物理地址

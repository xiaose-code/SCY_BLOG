---
title:  爬楼梯
date: 2023-11-24 16:30:01
permalink: /pages/6b01fc/
---
# [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

## 题目：

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

## 示例：

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**

- `1 <= n <= 45`

## 解题：

#### 方法一：动态规划

一级台阶一种方法，二级台阶两种方法（1+1，2），三级台阶三种方法（1+1+1，1+2，2+1）。。。

- n=1, f(n) = 1;
- n=2, f(n) = 2;
- n=3, f(n) = 3;
- n=4, f(n) = 5;

这不是斐波那契数列吗？f(n) = f(n-2) + f(n-1)；

```CPP
class Solution {
public:
    int climbStairs(int n) {
        int first = 0, second = 0, third = 1;
        for(int i = 1; i <= n; ++i) {
            first = second;
            second = third;
            third = first + second;
        }
        return third;
    }
};
```

**复杂度分析**

- 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。
- 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。

#### 方法二：dp动态规划三部曲

1. 定义dp数组
   我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
2. 找出递推关系式
   动态规划类似于高中数学的数学归纳法，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。
3. 找出初始值
   找出了递推公式，我们还需要初始值，因为递推公式就是靠前面的值推出后面的值，但总得有个头吧，这个头就是初始值。

```CPP
#include <vector>
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) {
            return 1;
        }
        std::vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; ++i) {
            dp[i] = dp[i - 1] + dp[i -2];
        }
        return dp[n];
    }
};
```


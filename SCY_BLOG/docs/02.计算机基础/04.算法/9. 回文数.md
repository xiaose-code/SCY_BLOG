---
title:  回文数
date: 2023-12-28 14:58:20
permalink: /pages/af836b/
---
# [9. 回文数](https://leetcode.cn/problems/palindrome-number/)

## 题目：

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

## 示例：

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

**提示：**

- `-231 <= x <= 231 - 1`

**进阶：**你能不将整数转为字符串来解决这个问题吗？

## 解题：

### 方法一：数学方法

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字。

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![1703468503719](https://cdn.jsdelivr.net/gh/xiaose-code/Pictures@main/img/1703468503719.webp)

```CPP
class Solution {
public:
    bool isPalindrome(int x) {
        // 负数和以0结尾的数字不是回文数
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int reversedNumber = 0;
        // 将后半部分数字反转
        while (x > reversedNumber) {
            reversedNumber = reversedNumber * 10 + x % 10;
            x /= 10;
        }

        // 判断是否为回文数
        return x == reversedNumber || x == reversedNumber / 10;
    }
};
```

**复杂度：**

- 时间复杂度：O(n)，其中 n 是整数的位数，因为需要遍历整个数字的每一位。
- 空间复杂度：O(n)，需要使用额外的空间来存储整数的字符串表示。

### 方法二：将整数转换为字符串

其主要步骤如下：

1. 将整数转换为字符串。
2. 使用双指针，一个指针指向字符串的开头，另一个指针指向字符串的末尾。
3. 不断比较两个指针指向的字符是否相等，如果相等，则向中间移动继续比较；如果不相等，直接返回 `false`。
4. 如果整个过程都能够完成，说明整数是回文数，返回 `true`。

```CPP
#include <string>

class Solution {
public:
    bool isPalindrome(int x) {
        // 将整数转换为字符串
        std::string str = std::to_string(x);
        
        // 使用双指针判断是否为回文
        int left = 0;
        int right = str.length() - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
};
```

**复杂度：**

- 时间复杂度：O(log~10~(x))，其中 x 是整数的大小，因为反转过程需要除以 10。
- 空间复杂度：O(1)，只使用常数级别的额外空间。